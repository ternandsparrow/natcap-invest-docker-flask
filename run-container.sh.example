#!/bin/bash
# starts/restarts our container
# In local dev mode we also
#  - create a static file server so it's easier to get the workspace files
#  - set the flag so workspace files are NOT purged after a run
set -euo pipefail
cd `dirname "$0"`

# you can change the bound host ports
export NATCAP_PORT=5000
export FILES_PORT=5001

# TODO change this to the Docker image tag you want to run
export NATCAP_TAG=`git tag | tail -n 1`

# uncomment the following for a production deploy
# export NIDF_ENV=production
export SOCKETIO_SECRET=${SOCKETIO_SECRET:-`uuidgen`}

isLocalDevMode=`[ ! -z "${LOCAL_DEV:-}" ]`

if $isLocalDevMode; then
  DC_OVERRIDE_FRAGMENT='--file docker-compose.yml --file docker-compose.local-dev.yml'
fi

echo "[INFO] $(date) - starting stack"
docker-compose ${DC_OVERRIDE_FRAGMENT:-} up -d $@

if $isLocalDevMode; then
  cat <<EOF
[INFO] you're in local dev mode so we've dropped you to a shell.
 - Start the app with ./docker/run.sh.
 - You can Ctrl-c back to this shell and inspect the output files in
   /workspace.
 - Add the code 'import pdb; pdb.set_trace()' in the source to trigger the
   python debugger in here.
 - A static file server is running on http://localhost:${FILES_PORT} so you can
   inspect the /workspace files with your web browser.
EOF
  docker exec -it natcap bash
  echo "[INFO] you've left the container but the stack is still running. To "
  echo "       kill it, run:"
  echo "  docker-compose down --volumes --remove-orphans"
else
  echo "[INFO] stack started"
fi
