#!/bin/bash
# starts/restarts our container
# You don't need the code locally, you can just deploy this script to a host
# with docker and run it. Purposely built to be editable so you just run the
# script and all your settings are still intact. If we accepted params, you
# might forget to pass them on subsequent runs and accidentally run in dev mode
# instead of prod, etc.
set -euo pipefail

name=natcap
hostPort=5000

# TODO change this to the Docker image tag you want to run
dockerTag=`git tag | tail -n 1`

# uncomment the following for a production deploy
#theEnv=production
#restartPolicy=unless-stopped
socketioSecret=${SOCKETIO_SECRET:-`uuidgen`}

existingContainerId=`docker ps -a -q -f name="^${name}$"`
if [ ! -z "$existingContainerId" ]; then
  echo "[INFO] killing existing container $existingContainerId"
  docker rm -f $name > /dev/null
fi

detach='--detach'

if [ ! -z "${LOCAL_DEV:-}" ]; then
  dontPurge=0 # keeps outputs in work dir after run
  detach='-it'
  fragment="-v $(pwd):/app --entrypoint bash -e PURGE_WORKSPACE=$dontPurge"
  cat <<EOF
[INFO] you're in local dev mode so we've dropped you to a shell.
 - Start the app with ./docker/run.sh.
 - You can also Ctrl-c back to this shell and inspect the output files in
   /workspace.
 - Add the code 'import pdb; pdb.set_trace()' in the source to trigger the
   python debugger in here.
 - If running the official NatCap sample data, our setuid magic breaks down in
   this "local dev" env. To fix this, run in a separate terminal:
      docker exec -it --user 0 natcap bash # start a root shell
      ./docker/prep-for-sample-data-run.sh # run the prep
   ...then you can come back here and carry on without error.
EOF
fi

echo "[INFO] starting container"
docker run \
  $detach \
  --name=$name \
  -p $hostPort:5000 \
  -e NIDF_ENV=${NIDF_ENV:-development} \
  -e SOCKETIO_SECRET=${socketioSecret} \
  --restart=${restartPolicy:-no} \
  ${fragment:-} \
  ternandsparrow/natcap-invest-docker-flask:$dockerTag
